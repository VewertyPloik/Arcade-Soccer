<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Arcade Soccer v2 - Drag & Shoot</title>
  <style>
    body {
      margin: 0; background: #0b6623;
      display: flex; justify-content: center; align-items: center; height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
      touch-action: none; /* prevent scrolling on touch drag */
    }
    #gameCanvas {
      background: #116622;
      border: 4px solid #fff;
      box-sizing: border-box;
      display: block;
      touch-action: none;
    }
    #ui {
      position: fixed; top: 10px; width: 100%; text-align: center;
      color: white; font-size: 24px; font-weight: bold; text-shadow: 0 0 5px black;
      user-select:none;
    }
    #message {
      position: fixed; bottom: 20px; width: 100%; text-align: center;
      color: yellow; font-size: 28px; font-weight: bold; text-shadow: 0 0 8px black;
      user-select:none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="500"></canvas>
  <div id="ui">Player 0 - 0 AI | Time: 02:00</div>
  <div id="message"></div>

  <script>
  (() => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    // Game constants
    const PLAYER_SPEED = 3.5;
    const AI_SPEED = 2.5;
    const BALL_FRICTION = 0.97;
    const BALL_MAX_SPEED = 10;
    const GOAL_WIDTH = 140;
    const GAME_DURATION = 2 * 60; // seconds
    const PLAYER_HALF = 'left';
    const AI_HALF = 'right';

    // Entities
    class Entity {
      constructor(x, y, radius, color) {
        this.x = x;
        this.y = y;
        this.radius = radius;
        this.color = color;
        this.vx = 0;
        this.vy = 0;
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
      }
      distanceTo(entity) {
        return Math.hypot(this.x - entity.x, this.y - entity.y);
      }
    }

    class Player extends Entity {
      constructor(x, y, color) {
        super(x, y, 15, color);
      }
      move(dx, dy) {
        this.x += dx * PLAYER_SPEED;
        this.y += dy * PLAYER_SPEED;
        this.clampPosition();
      }
      clampPosition() {
        // Stay in left half
        this.x = Math.min(Math.max(this.radius, this.x), width/2 - this.radius);
        this.y = Math.min(Math.max(this.radius, this.y), height - this.radius);
      }
    }

    class AIPlayer extends Entity {
      constructor(x, y, color) {
        super(x, y, 15, color);
      }
      update(ball, player) {
        // Defensive AI logic:
        // Move towards ball if near or block player if near ball
        let targetX, targetY;
        const distToBall = this.distanceTo(ball);
        const distPlayerBall = player.distanceTo(ball);

        if(distToBall < 130) {
          // Chase ball
          targetX = ball.x;
          targetY = ball.y;
        } else if(distPlayerBall < 130) {
          // Block player
          targetX = player.x;
          targetY = player.y;
        } else {
          // Patrol middle of AI half
          targetX = width * 0.75;
          targetY = height/2;
        }

        let dx = targetX - this.x;
        let dy = targetY - this.y;
        let dist = Math.hypot(dx, dy);
        if(dist > 1) {
          this.x += (dx / dist) * AI_SPEED;
          this.y += (dy / dist) * AI_SPEED;
        }
        this.clampPosition();
      }
      clampPosition() {
        // AI stays in right half
        this.x = Math.min(Math.max(width/2 + this.radius, this.x), width - this.radius);
        this.y = Math.min(Math.max(this.radius, this.y), height - this.radius);
      }
    }

    class Ball extends Entity {
      constructor(x, y) {
        super(x, y, 10, 'white');
        this.controlledByPlayer = false;
        this.controlledByAI = false;
        this.dragging = false;
        this.dragStart = null;
        this.dragVector = null;
      }
      update() {
        if(!this.dragging) {
          this.x += this.vx;
          this.y += this.vy;

          // Friction
          this.vx *= BALL_FRICTION;
          this.vy *= BALL_FRICTION;

          // Clamp speed
          const speed = Math.hypot(this.vx, this.vy);
          if(speed > BALL_MAX_SPEED) {
            this.vx = (this.vx / speed) * BALL_MAX_SPEED;
            this.vy = (this.vy / speed) * BALL_MAX_SPEED;
          }

          // Bounce top/bottom
          if(this.y < this.radius) {
            this.y = this.radius;
            this.vy = -this.vy;
          } else if(this.y > height - this.radius) {
            this.y = height - this.radius;
            this.vy = -this.vy;
          }

          // Bounce left/right except goals
          if(this.x < this.radius) {
            // Check goal for AI
            if(this.y > height/2 - GOAL_WIDTH/2 && this.y < height/2 + GOAL_WIDTH/2) {
              scoreAI++;
              resetPositions();
              showMessage('GOAL for AI!');
            } else {
              this.x = this.radius;
              this.vx = -this.vx * 0.6;
            }
          } else if(this.x > width - this.radius) {
            // Check goal for Player
            if(this.y > height/2 - GOAL_WIDTH/2 && this.y < height/2 + GOAL_WIDTH/2) {
              scorePlayer++;
              resetPositions();
              showMessage('GOAL for Player!');
            } else {
              this.x = width - this.radius;
              this.vx = -this.vx * 0.6;
            }
          }
        }
      }
    }

    // Globals
    const player = new Player(100, height/2, '#ff4d4d');
    const ball = new Ball(width/2, height/2);
    const aiPlayers = [
      new AIPlayer(width * 0.75, height/3, '#3399ff'),
      new AIPlayer(width * 0.75, height * 2/3, '#3399ff'),
    ];

    let keys = {};
    let scorePlayer = 0;
    let scoreAI = 0;
    let timeLeft = GAME_DURATION;
    let gameOver = false;
    let messageTimeout;

    // UI Elements
    const ui = document.getElementById('ui');
    const messageDiv = document.getElementById('message');

    // Input handling
    window.addEventListener('keydown', e => {
      keys[e.key.toLowerCase()] = true;
      if(gameOver && e.key === 'Enter') {
        resetGame();
      }
    });
    window.addEventListener('keyup', e => {
      keys[e.key.toLowerCase()] = false;
    });

    // Touch handling for dragging ball (mobile)
    let ongoingTouchId = null;

    canvas.addEventListener('touchstart', e => {
      if(gameOver) return;
      const touch = e.changedTouches[0];
      ongoingTouchId = touch.identifier;
      const rect = canvas.getBoundingClientRect();
      const tx = touch.clientX - rect.left;
      const ty = touch.clientY - rect.top;

      // Check if player is near ball (possession)
      if(player.distanceTo(ball) < player.radius + ball.radius + 5) {
        // Check if touch inside ball radius
        if(Math.hypot(tx - ball.x, ty - ball.y) <= ball.radius + 10) {
          ball.dragging = true;
          ball.dragStart = {x: tx, y: ty};
          ball.dragVector = null;
          ball.vx = 0;
          ball.vy = 0;
          ball.controlledByPlayer = true;
          ball.controlledByAI = false;
          e.preventDefault();
        }
      }
    }, {passive:false});

    canvas.addEventListener('touchmove', e => {
      if(!ball.dragging) return;
      for(let touch of e.changedTouches){
        if(touch.identifier === ongoingTouchId) {
          const rect = canvas.getBoundingClientRect();
          const tx = touch.clientX - rect.left;
          const ty = touch.clientY - rect.top;

          // Move ball with touch but keep inside field
          ball.x = Math.min(Math.max(ball.radius, tx), width - ball.radius);
          ball.y = Math.min(Math.max(ball.radius, ty), height - ball.radius);

          // Calculate drag vector (drag back from start point)
          ball.dragVector = {
            x: ball.dragStart.x - tx,
            y: ball.dragStart.y - ty
          };
          e.preventDefault();
        }
      }
    }, {passive:false});

    canvas.addEventListener('touchend', e => {
      if(!ball.dragging) return;
      for(let touch of e.changedTouches){
        if(touch.identifier === ongoingTouchId) {
          if(ball.dragVector) {
            // Shoot ball with drag vector
            const powerFactor = 0.3; // tune power
            ball.vx = ball.dragVector.x * powerFactor;
            ball.vy = ball.dragVector.y * powerFactor;

            // Limit max speed
            let speed = Math.hypot(ball.vx, ball.vy);
            if(speed > BALL_MAX_SPEED) {
              ball.vx = (ball.vx / speed) * BALL_MAX_SPEED;
              ball.vy = (ball.vy / speed) * BALL_MAX_SPEED;
            }
          }
          ball.dragging = false;
          ball.dragStart = null;
          ball.dragVector = null;
          ongoingTouchId = null;
          e.preventDefault();
        }
      }
    }, {passive:false});

    function resetPositions() {
      ball.x = width/2;
      ball.y = height/2;
      ball.vx = 0;
      ball.vy = 0;
      ball.dragging = false;
      ball.controlledByPlayer = false;
      ball.controlledByAI = false;

      player.x = 100;
      player.y = height/2;

      aiPlayers[0].x = width * 0.75;
      aiPlayers[0].y = height/3;

      aiPlayers[1].x = width * 0.75;
      aiPlayers[1].y = height * 2/3;
    }

    function resetGame() {
      scorePlayer = 0;
      scoreAI = 0;
      timeLeft = GAME_DURATION;
      gameOver = false;
      messageDiv.textContent = '';
      resetPositions();
    }

    function showMessage(text) {
      messageDiv.textContent = text;
      clearTimeout(messageTimeout);
      messageTimeout = setTimeout(() => {
        messageDiv.textContent = '';
      }, 2500);
    }

    // Player controls for movement (WASD/arrow keys)
    function handlePlayer() {
      if(ball.dragging) return; // Can't move player while dragging ball

      let dx = 0;
      let dy = 0;
      if(keys['arrowup'] || keys['w']) dy = -1;
      if(keys['arrowdown'] || keys['s']) dy = 1;
      if(keys['arrowleft'] || keys['a']) dx = -1;
      if(keys['arrowright'] || keys['d']) dx = 1;

      if(dx !== 0 && dy !== 0) {
        dx *= Math.SQRT1_2;
        dy *= Math.SQRT1_2;
      }

      player.move(dx, dy);

      // If player bumps into ball and ball not controlled, gain control
      if(player.distanceTo(ball) < player.radius + ball.radius + 5 && !ball.dragging) {
        ball.controlledByPlayer = true;
        ball.controlledByAI = false;
      }
    }

    // AI defenders logic
    function handleAI() {
      // If ball controlled by player, AI tries to steal (touch ball)
      // If ball controlled by AI, player must bump to steal it back
      aiPlayers.forEach(ai => {
        ai.update(ball, player);

        if(ball.controlledByPlayer) {
          // AI tries to reach ball and steal
          if(ai.distanceTo(ball) < ai.radius + ball.radius + 5) {
            // AI steals ball
            ball.controlledByPlayer = false;
            ball.controlledByAI = true;
            showMessage('AI stole the ball!');
          }
        } else if(ball.controlledByAI) {
          // AI moves ball with velocity (basic)
          ball.x = ai.x + (Math.random()*20-10);
          ball.y = ai.y + (Math.random()*20-10);
          ball.vx = 0;
          ball.vy = 0;

          // AI tries to shoot towards player goal if near half line
          if(ball.x < width * 0.6) {
            // Shoot towards player goal center
            let dx = -10;
            let dy = (height/2 - ball.y) * 0.1;
            ball.vx = dx;
            ball.vy = dy;
            ball.controlledByAI = false;
            showMessage('AI shoots!');
          }
        }
      });

      // If ball controlled by AI and player bumps into ball, steal it back
      if(ball.controlledByAI && player.distanceTo(ball) < player.radius + ball.radius + 5) {
        ball.controlledByAI = false;
        ball.controlledByPlayer = true;
        showMessage('You stole the ball back!');
      }
    }

    // Draw field lines, goals (white boxes)
    function drawField() {
      ctx.fillStyle = '#116622';
      ctx.fillRect(0, 0, width, height);

      // Mid line
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(width/2, 0);
      ctx.lineTo(width/2, height);
      ctx.stroke();

      // Center circle
      ctx.beginPath();
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'white';
      ctx.arc(width/2, height/2, 70, 0, Math.PI*2);
      ctx.stroke();

      // Goals - white rectangles on sides
      ctx.fillStyle = 'white';
      // Left goal
      ctx.fillRect(0, height/2 - GOAL_WIDTH/2, 15, GOAL_WIDTH);
      // Right goal
      ctx.fillRect(width - 15, height/2 - GOAL_WIDTH/2, 15, GOAL_WIDTH);

      // Penalty spots
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(80, height/2, 5, 0, Math.PI*2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(width - 80, height/2, 5, 0, Math.PI*2);
      ctx.fill();
    }

    function drawUI() {
      let minutes = Math.floor(timeLeft / 60);
      let seconds = Math.floor(timeLeft % 60).toString().padStart(2, '0');
      ui.textContent = `Player ${scorePlayer} - ${scoreAI} AI | Time: ${minutes}:${seconds}`;
    }

    // Draw dragging arrow on ball when dragging (mobile)
    function drawDragArrow() {
      if(ball.dragging && ball.dragVector) {
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(ball.x, ball.y);
        ctx.lineTo(ball.x + ball.dragVector.x, ball.y + ball.dragVector.y);
        ctx.stroke();

        // Arrowhead
        const angle = Math.atan2(ball.dragVector.y, ball.dragVector.x);
        const arrowLength = 15;
        ctx.beginPath();
        ctx.moveTo(ball.x + ball.dragVector.x, ball.y + ball.dragVector.y);
        ctx.lineTo(ball.x + ball.dragVector.x - arrowLength * Math.cos(angle - Math.PI/6), ball.y + ball.dragVector.y - arrowLength * Math.sin(angle - Math.PI/6));
        ctx.lineTo(ball.x + ball.dragVector.x - arrowLength * Math.cos(angle + Math.PI/6), ball.y + ball.dragVector.y - arrowLength * Math.sin(angle + Math.PI/6));
        ctx.closePath();
        ctx.fillStyle = 'yellow';
        ctx.fill();
      }
    }

    // Main game loop
    let lastTime = 0;
    function loop(timestamp = 0) {
      if(gameOver) {
        drawField();
        player.draw();
        ball.draw();
        aiPlayers.forEach(p => p.draw());
        drawUI();
        requestAnimationFrame(loop);
        return;
      }

      const delta = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      timeLeft -= delta;
      if(timeLeft <= 0) {
        timeLeft = 0;
        gameOver = true;
        if(scorePlayer > scoreAI) showMessage('Game Over! You Win! Press Enter to Restart');
        else if(scoreAI > scorePlayer) showMessage('Game Over! AI Wins! Press Enter to Restart');
        else showMessage('Game Over! Draw! Press Enter to Restart');
      }

      handlePlayer();
      handleAI();
      ball.update();

      drawField();
      player.draw();
      aiPlayers.forEach(p => p.draw());
      ball.draw();
      drawDragArrow();
      drawUI();

      requestAnimationFrame(loop);
    }

    resetGame();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
